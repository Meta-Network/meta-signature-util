import crypto from 'crypto';
import * as curve from 'curve25519-js';
import niceware from 'niceware';
import type {
  KeyPair,
  KeyValuePair,
  MetadataInPayload,
  SignatureMetadata,
  AuthorDigestRequestMetadata,
  PostMetadata,
  AuthorSignatureMetadata,
} from '../type/types';

/**
 * Convert Uint8 TypedArray to hex string, also append '0x' to the start.
 * @param {Uint8Array} uint8 TypeArray to convert
 * @returns {string} result string
 */
export const uint8ToHexString = (uint8: Uint8Array): string =>
  `0x${Buffer.from(uint8).toString('hex')}`;

/**
 * Convert hex string back to Uint8 TypedArray.
 * Code is from: https://stackoverflow.com/a/50868276/5299236
 * @param {string} hexString
 * @returns {Uint8Array}
 */
export const hexStringToUint8 = (hexString: string) =>
  new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));

/**
 * Create a nonce for signing messages.
 * @returns {string} nonce string
 */
export const createNonce = () => uint8ToHexString(crypto.randomBytes(12));

/**
 * Generate a random 16 words (32bits length) passphrase as seed by niceware.
 * You can pass the seed to generateKey function.
 * @returns {string[]} passphrase array
 */
export const generateSeed = (): string[] => niceware.generatePassphrase(32);

/**
 * Generates a new key pair from the given seed and returns it as object.
 * Each word of the passphrase array should be in the 'niceware' wordlist.
 * see: https://www.npmjs.com/package/niceware
 * @param {string[]} passphrase
 * @returns {{public: Uint8Array, private: Uint8Array}} key pair
 */
export const generateKeys = (
  passphrase: string[],
): { public: Uint8Array; private: Uint8Array } => {
  const seed = niceware.passphraseToBytes(passphrase);
  return curve.generateKeyPair(seed);
};

/**
 * Create a key-value based string for sign.
 * Input can be any object with string values,
 * but recommend to use the type MetadataInPayload.
 * @param {{[p: string]: string}} metadata
 * @param {number} timestamp
 * @returns {{payload: string, timestamp: number}}
 */
export const createKeyValueByMetadataPayload = (
  metadata: { [key: string]: string },
  timestamp?: number,
): {
  payload: string;
  timestamp: number;
} => {
  const sortMetadataByTitle = (a: KeyValuePair, b: KeyValuePair) => {
    // eslint-disable-next-line no-nested-ternary
    return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;
  };

  const payloadBase = Object.entries(metadata)
    .sort(sortMetadataByTitle)
    .map((e) => e.map((i) => encodeURIComponent(i as string)).join('='))
    .join('&');

  const ts = timestamp ?? Date.now();
  const payload = `${payloadBase}&ts=${ts}`;

  return {
    payload,
    timestamp: ts,
  };
};

/**
 * Create a sha256 digest based on input string.
 * In this project, it could be a key-value string,
 * that created by function createKeyValueByMetadataPayload.
 * @param {string} payload
 * @returns {string}
 */
// TODO: should find a package for frontend
export const createDigest = (payload: string): string =>
  `0x${crypto.createHash('sha256').update(payload).digest('hex')}`;

export const createSignature = (
  privateKey: Uint8Array,
  payload: string,
): string =>
  uint8ToHexString(curve.sign(privateKey, hexStringToUint8(payload), null));

/**
 * Verify digest generated by generatePostDigestRequestMetadata,
 * need it's output as the input.
 * @param {AuthorDigestRequestMetadata} metadata to verify
 * @returns {boolean} verify result
 */
export const verifyDigest = (metadata: AuthorDigestRequestMetadata) => {
  const postMetadata: PostMetadata = {
    title: metadata.title,
    categories: metadata.categories,
    content: metadata.content,
    cover: metadata.cover,
    licence: metadata.licence,
    summary: metadata.summary,
    tags: metadata.tags,
  };

  const { payload } = createKeyValueByMetadataPayload(
    postMetadata,
    metadata.ts,
  );
  return metadata.digest === createDigest(payload);
};

/**
 * Verify curve25519 signature generated by other functions.
 * Signature and publicKey must in the metadata.
 * If a payload contains another hash, pass it as the second param.
 * @param {AuthorDigestRequestMetadata} metadata to verify
 * @param hash to be automatically inserted to the payload
 * @returns {boolean} verify result
 */
export const verifyMetadataSignature = (
  metadata: SignatureMetadata,
  hash?: string,
): boolean => {
  const metadataPayload: Partial<MetadataInPayload> = {
    nonce: metadata.nonce,
    claim: metadata.claim,
  };

  if (hash) {
    metadataPayload.hash = hash;
  }

  const { payload } = createKeyValueByMetadataPayload(
    metadataPayload,
    metadata.ts,
  );

  // convert hex strings to Uint8Array
  const [keyUint8, payloadUint8, signatureUint8] = [
    metadata.publicKey.slice(2),
    payload,
    metadata.signature.slice(2),
  ].map((string) => hexStringToUint8(string));

  return curve.verify(keyUint8, payloadUint8, signatureUint8);
};

export const generatePostDigestRequestMetadata = (
  postMetadata: PostMetadata,
): AuthorDigestRequestMetadata => {
  const authorDigestRequestMetadataHeader: Partial<AuthorDigestRequestMetadata> =
    {
      '@context': 'https://metanetwork.online/ns/cms',
      type: 'author-digest',
      algorithm: 'sha256',
      version: '2021-11-01-01',
      ...postMetadata,
    };

  const { payload, timestamp } = createKeyValueByMetadataPayload(postMetadata);
  const digest = createDigest(payload);

  const authorDigestRequestMetadata = {
    ...authorDigestRequestMetadataHeader,
    digest,
    ts: timestamp,
  };
  return authorDigestRequestMetadata as AuthorDigestRequestMetadata;
};

export const generateAuthorDigestSignMetadata = (
  authorKeys: KeyPair,
  serverDomain: string,
  digest: string,
): AuthorSignatureMetadata => {
  const publicKey = uint8ToHexString(authorKeys.public);

  const authorDigestSignatureMetadataHeader: Partial<AuthorSignatureMetadata> =
    {
      '@context': 'https://metanetwork.online/ns/cms',
      type: 'author-digest-sign',
      signatureAlgorithm: 'curve25519',
      version: '2021-11-01-01',
      publicKey,
    };

  const authorDigestSignaturePayload: Partial<MetadataInPayload> = {
    hash: digest,
    nonce: createNonce(),
    claim: `I authorize publishing by ${serverDomain} from this device using key: ${publicKey}`,
  };

  const { payload, timestamp } = createKeyValueByMetadataPayload(
    authorDigestSignaturePayload,
  );
  const signature = createSignature(authorKeys.private, payload);

  const authorDigestSignatureMetadata = {
    ...authorDigestSignatureMetadataHeader,
    ...authorDigestSignaturePayload,
    digest,
    signature,
    ts: timestamp,
  };
  return authorDigestSignatureMetadata as AuthorSignatureMetadata;
};

export const generateAuthorDigestSignServerVerificationMetadata = (
  serverKeys: KeyPair,
  serverDomain: string,
  authorDigestSignatureMetadata: AuthorSignatureMetadata,
  authorDigestSignatureMetadataRefer: string,
): SignatureMetadata => {
  const publicKey = uint8ToHexString(serverKeys.public);
  const authorSignature = authorDigestSignatureMetadata.signature;

  const serverVerificationSignatureMetadataHeader: Partial<SignatureMetadata> =
    {
      '@context': 'https://metanetwork.online/ns/cms',
      type: 'server-verification-sign',
      signatureAlgorithm: 'curve25519',
      version: '2021-11-01-01',
      publicKey,
    };

  const serverVerificationSignatureMetadataPayload: Partial<MetadataInPayload> =
    {
      hash: authorSignature,
      nonce: createNonce(),
      claim: `I, ${serverDomain} authorize request (sign: ${authorSignature}) from device using key: ${publicKey}`,
    };

  const { payload, timestamp } = createKeyValueByMetadataPayload(
    serverVerificationSignatureMetadataPayload,
  );
  const signature = createSignature(serverKeys.private, payload);

  const serverVerificationSignatureMetadata = {
    ...serverVerificationSignatureMetadataHeader,
    nonce: serverVerificationSignatureMetadataPayload.nonce,
    claim: serverVerificationSignatureMetadataPayload.claim,
    signature,
    ts: timestamp,
    reference: [
      {
        refer: authorDigestSignatureMetadataRefer,
        body: authorDigestSignatureMetadata,
      },
    ],
  };
  return serverVerificationSignatureMetadata as SignatureMetadata;
};

export const generateAuthorDigestSignWithContentServerVerificationMetadata = (
  authorDigestRequestMetadata: AuthorDigestRequestMetadata,
  authorDigestRequestMetadataRefer: string,
  serverVerificationSignatureMetadata: SignatureMetadata,
): SignatureMetadata => {
  serverVerificationSignatureMetadata.reference.unshift({
    refer: authorDigestRequestMetadataRefer,
    body: authorDigestRequestMetadata,
  });
  return serverVerificationSignatureMetadata;
};

export const generateAuthorPublishMetaSpaceRequestMetadata = (
  authorKeys: KeyPair,
  serverDomain: string,
): SignatureMetadata => {
  const publicKey = uint8ToHexString(authorKeys.public);

  const authorPublishRequestMetadataHeader: Partial<SignatureMetadata> = {
    '@context': 'https://metanetwork.online/ns/cms',
    type: 'author-publish-meta-space-request',
    signatureAlgorithm: 'curve25519',
    version: '2021-11-01-01',
    publicKey,
  };

  const authorPublishRequestPayload: Partial<MetadataInPayload> = {
    nonce: createNonce(),
    claim: `I authorize publishing Meta Space by ${serverDomain} from this device using key: ${publicKey}`,
  };

  const { payload, timestamp } = createKeyValueByMetadataPayload(
    authorPublishRequestPayload,
  );
  const signature = createSignature(authorKeys.private, payload);

  const authorPublishRequestMetadata = {
    ...authorPublishRequestMetadataHeader,
    ...authorPublishRequestPayload,
    signature,
    ts: timestamp,
  };
  return authorPublishRequestMetadata as SignatureMetadata;
};

export const generatePublishMetaSpaceServerVerificationMetadata = (
  serverKeys: KeyPair,
  serverDomain: string,
  authorPublishMetaSpaceRequestMetadata: SignatureMetadata,
  authorPublishMetaSpaceRequestMetadataRefer: string,
): SignatureMetadata => {
  const publicKey = uint8ToHexString(serverKeys.public);
  const authorSignature = authorPublishMetaSpaceRequestMetadata.signature;

  const serverVerificationSignatureMetadataHeader: Partial<SignatureMetadata> =
    {
      '@context': 'https://metanetwork.online/ns/cms',
      type: 'author-publish-meta-space-server-verification-sign',
      signatureAlgorithm: 'curve25519',
      version: '2021-11-01-01',
      publicKey,
    };

  const serverVerificationSignatureMetadataPayload: Partial<MetadataInPayload> =
    {
      hash: authorSignature,
      nonce: createNonce(),
      claim: `I, ${serverDomain} authorize request (sign: ${authorSignature}) from device using key: ${publicKey}`,
    };

  const { payload, timestamp } = createKeyValueByMetadataPayload(
    serverVerificationSignatureMetadataPayload,
  );
  const signature = createSignature(serverKeys.private, payload);

  const serverVerificationSignatureMetadata = {
    ...serverVerificationSignatureMetadataHeader,
    nonce: serverVerificationSignatureMetadataPayload.nonce,
    claim: serverVerificationSignatureMetadataPayload.claim,
    signature,
    ts: timestamp,
    reference: [
      {
        refer: authorPublishMetaSpaceRequestMetadataRefer,
        body: authorPublishMetaSpaceRequestMetadata,
      },
    ],
  };
  return serverVerificationSignatureMetadata as SignatureMetadata;
};
